# Noise Reduction for IBMQ
NC State ECE 592/CSC 591 Quantum Computing Project One: IBM Q Pulses to Reduce Noise
Contributors: Ayush Khot, Johnathan Wilder, Ruiwen Wu

## Demo Instructions
git clone https://github.ncsu.edu/jrwilde2/ECE592-CSC591_project1.git

**Dependencies:**
- pip install qiskit
- pip install matplotlib
- pip install numpy

**Files to run:**
The source file "calibrate_pi_pulse_updated.ipynb" is the main python notebook that you can run to see the code in the presentation.
The source file "calibrate_pi_pulse_repeatExperiment.ipynb" is similar to the the updated python notebook but we use this one to vary the sigma values of the Gaussian pulse. The excel spreadsheet values has the parameters organized and graphed to determine the best pulse.

## Project Results: [project](https://docs.google.com/presentation/u/0/d/1xaBUYWozTSTd02V0RWSkVRXBIVty5xfrjSIyqffaeUY/edit)

## Problem Description
One of the major challenges prevalent in the quantum computing paradigm is noisy quantum devices. Quantum devices, in practice, are often prone to incorrect answers due to noise in the system as a result of decoherence. This limits our ability to have a reliable output from quantum computers in solving problems. Quantum computers with uncorrelated and weak noise can potentially be used to solve intractable problems. A tremendous amount of work has already been done in this area to design more fault-tolerant quantum machines. With our proposed solution, we aim to minimize the noisy results obtained in currently available quantum computers for low level single qubit gates.

IBM quantum computers are controlled with precise pulses that stimulate transmon qubits and manipulate their states. IBM’s Qiskit library contains the Pulse API, which allows users to have pulse-level control of quantum systems. This lower level of programming  allows users to have a greater level of control and implementation of gates and measurements than what is capable with a higher level API like Qiskit’s QuantumCircuit. The pulse level control will allow experimentation with different pulses in order to correct the average noise found in a quantum circuit. Once an optimal pulse is determined, a calibration circuit can be constructed and the base vectors, |0> and |1>, can be redefined. This will allow the reconstruction of standard gates such as Pauli, Hadamard, etc. with comparatively lower noise levels that result in more consistently correct answers.


## Proposed solution
Determine an optimal pulse to correct the average noise found in low-level u1, u2, and u3 gates. Then, using said optimal pulse, develop a calibration circuit.
- Begin with IBM’s default pulses for 180 degree rotations around the X and Z axis to develop an understanding of how to use Qiskit Pulse and manipulate pulses to achieve a certain result.
- Use OpenPulse to understand how a C-NOT gate works and how pulses can be used to correct it’s result.
- Develop Pauli, C-NOT, and Hadamard gates using known pulse algorithms.
- Experiment with different pulses for low-level u1, u2, and u3 gates:
	- Run multiple simulations of u1, u2, and u3 gates with Qiskit Pulse and define an average error or noise level to be corrected using an optimal pulse.
	- As a baseline, a set of default pulse values and parameters will be initially selected and simulated on the standard u1, u2, and u3 gates to develop an understanding of the noise correction.
	- Experiment with different pulses until an optimal pulse is determined in order to correct the average error generated by the standard u1, u2, and u3 gates.
- Once the optimal pulse is found, develop a calibration circuit to be used to correct the error generated by the standard u1, u2, and u3 gates.
- Analyze and measure the calibration circuit using the optimal pulse and compare against the original circuit:
	- Horizontally compare results using the same gates and different pulse values.
	- Vertically compare results between different gates and the same pulse values.
	- Ensure greater fidelity of the error correcting circuit.
- Once the calibration circuit has been verified to reduce noisy results, redefine what the basis vectors, |0> and |1>, mean.

After experimentation has been done to find the best pulse to minimize the noise, or error, in the low-level u1, u2, and u3 gates, construct new circuits for each gate that incorporates the noise correction pulse.
- Once the new u1, u2, and u3 gate circuits have been constructed, the circuits must be simulated on a real quantum machine in order to prove a higher fidelity of results compared to the original u1, u2, u3 gate results. The machine we will use to test the new circuit will be the IBM Q Hub at NC State.
- Using the new, less noisy, u1, u2, and u3 gates, standard gates such as NOT, CNOT, Pauli, Hadamart, etc. must be rewritten automatically.
- Again, we must verify our results by running the newly developed standard gate circuits on a real quantum machine by comparing the results against the original standard gates.


## Timeline Outline
- 10/12/2020 - 10/19/2020
	- Ayush, Johnathan, Ruiwen: Review suggested material provided by Dr. Mueller
	- Ayush, Johnathan, Ruiwen: Learn IBM Qiskit Pulse
- 10/19/2020 - 10/26/2020
	- Ayush: Use Qiskit Pulse to perform 180 degree rotation about x-axis
	- Johnathan: Use Qiskit Pulse to perform 180 degree rotation about z-axis
	- Ruiwen: Use Qiskit Pulse and OpenPulse to evaluate how C-NOT works and how pulses can be used to correct it’s result
- 10/26/2020 - 11/02/2020
	- Ayush: Develop a Hadamard gate using a known Pulse algorithm
	- Johnathan: Develop Pauli gates using known Pulse algorithms
	- Ruiwen: Develop a C-NOT gate using a known Pulse algorithm
	- Ayush: Experiment with different pulses for low-level u1 gate
		- Run multiple simulation of u1 gate with Qiskit Pulse and define an average error or noise level to be corrected
	- Johnathan: Experiment with different pulses for low-level u2 gate
		- Run multiple simulation of u2 gate with Qiskit Pulse and define an average error or noise level to be corrected
	- Ruiwen: Experiment with different pulses for low-level u3 gate
		- Run multiple simulation of u3 gate with Qiskit Pulse and define an average error or noise level to be corrected
- 11/02/2020 - 11/09/2020
	- Ayush: Experiment with different pulses for low-level u1 gate until an optimal error correcting pulse is determined
	- Johnathan: Experiment with different pulses for low-level u2 gate until an optimal error correcting pulse is determined
	- Ruiwen: Experiment with different pulses for low-level u3 gate until an optimal error correcting pulse is determined
	- Ayush: Develop a calibration circuit to correct the error generated by the u1 gate
	- Johnathan: Develop a calibration circuit to correct the error generated by the u2 gate
	- Ruiwen: Develop a calibration circuit to correct the error generated by the u3 gate
	- Ayush: Analyze and measure the calibration circuit for the u1 gate
	- Johnathan: Analyze and measure the calibration circuit for the u2 gate
	- Ruiwen: Analyze and measure the calibration circuit for the u3 gate
- 11/09/2020 - 11/17/2020
	- Ayush, Johnathan, Ruiwen: Once the calibration circuits have been verified to reduce error or noise, redefine what the basis vectors, |0> and |1>, mean
	- Ayush: Construct new circuit for u1 gate that incorporates the noise correction pulse, simulate the new circuit on IBM Q, and prove higher fidelity results
	- Johnathan: Construct new circuit for u2 gate that incorporates the noise correction pulse, simulate the new circuit on IBM Q, and prove higher fidelity results
	- Ruiwen: Construct new circuit for u3 gate that incorporates the noise correction pulse, simulate the new circuit on IBM Q, and prove higher fidelity results
	- Ayush: Using the new, less noisy, u1, u2, and u3 gates, reconstruct Hadamard gate, simulate the new gate on IBM Q, and prove higher fidelity results
	- Johnathan: Using the new, less noisy, u1, u2, and u3 gates, reconstruct Pauli gates, simulate the new gate on IBM Q, and prove higher fidelity results
	- Ruiwen: Using the new, less noisy, u1, u2, and u3 gates, reconstruct C-NOT gate, simulate the new gate on IBM Q, and prove higher fidelity results


## Progress Report
- 10/12/2020 - 10/19/2020
	- Ayush:
		- Read through Qiskit Pulse resources. (Introduction, Backend, Job Creation and Monitoring)
		- Gained understanding of IBM Pulse API. Specifically, how Pulse Drive works and the effect of Pulse parameters(Amplitude, Qubit Freq. etc.)
		- Read about the cause of noises in Quantum Machines
	- Johnathan:
		- Read through, reviewed, and familiarized myself with the resources available to us during homework 4 part 1. I also took note of which resources pertain to a particular subject within our project for easy reference
		- Completed two of the Qiskit Pulse tutorials which were getting started with open pulse and building Pulse instructions
	- Ruiwen:
		- Read through the DisQ paper provided by Dr. Mueller
		- Watched the Youtube Video for Qiskit OpenPulse
- 10/19/2020 - 10/26/2020
	- Ayush:
		- Getting started with Qiskit Pulse Tutorials.(Building Pulse Instructions and Schedule for standard 1 qubit operations)
		- Calibrating Quantum machines with appropriate frequency and pulse amplitudes(using Rabi Experiments) - **In Progress Ref: https://qiskit.org/textbook/ch-quantum-hardware/calibrating-qubits-pulse.html
		- Create Pulse Instructions to perform π rotation. - **In Progress
	- Johnathan:
		- Read through, reviewed, and familiarized myself with both the old and new resources now available to us. I also took note of which resources pertain to a particular subject within our project for easy reference
		- Revised the project description, proposed solution, and time-line sections of the report and structured the progress report section
		- Began writing code for programming a 180 degree rotation on the z-axis
	- Ruiwen:
        - Start on the tutorial on qiskit website to learn working with pulse
        - Read through the paper of Quantum Algorithm Implementations for Beginners to familiarize with building up general gates on qiskit
 - 10/26/2020 - 11/02/2020
    - Ayush:
        - Continued improving the calibration circuit to determine the Pulse Amplitude parameter and run simple pulse instructions to observe results
        - Started creating schedule instructions for U1,U2, U3 gates
    - Johnathan:
        - Realized I did not know enough about python and matplotlib so I tried to catch up on relevant python topics for the project
    - Ruiwen:
        - Start writing code with the pulse calibration tutorial
        - Research with different sigma, amplitude values for different pulses to find best fit for the pi pulse
 - 11/02/2020 - 11/09/2020
    - Ayush:
        - Manually experimented with setup parameters for the Rabi Oscillation experiment (Drive_duration, Drive_Sigma, Drive_Ampl)
        - Rewrite universal single qubit gates as Pulse schedule instructions
        - Perform test and comparison for recreated Pauli-X Gate on multiple iterations and compare against default X-Gate fidelity
    - Johnathan:
        - Continued to improve on python
        - Finished the code for 180 degree rotation about the z-axis
        - Joined Ayush and Ruiwen on finding the best pulse values
    - Ruiwen:
        - Conducted repeat experiments on sigma values pair with the amplitude to find out the best fit pairs for H-gate and X-gate
 - 11/09/2020 - 11/17/2020
    - Ayush:
        - Test other single-qubit gates(Hadamard, RZ, RY) with the calibrated universal gates
        - Setup experiment for calculating average over multiple iterations and analysing the results
    - Johnathan:
        - Managed the github repo, solved merge conflicts, added instructions to README
        - Updated report document
        - Made and setup the power point so Ayush and Ruiwen could add their respective results
        - Practiced the presentation
    - Ruiwen:
        - Plotting and analysing the results, researching further on multi-qubit machine and more precise experiment tools such as QCTRL

**Future Work**
- Enlarge the Gaussian pulse width research samples
- Conduct experiments with more precise methods to calculate the pulse values more accurately
- Extend and fine-tune the calibration circuit to perform pulse calibration on multi-qubit machines
- Use the multi-qubit calibrated pulse parameters to generate Pulse Schedule for CNOT gate
- Calibrating pulses for maximum performance on your hardware:
    - Use a waveform generator to calibrate and correct discrepancies between the pulse
- QCtrl References:
    - [QCtrl - Control Hardware: Calibration Pulse](https://app.q-ctrl.com/boulder-opal/launchPad/notebooks/application-notes/control-hardware-pulse-calibration.ipynb)
    - [QCtrl - SUPERCONDUCTING QUBITS: IMPROVING THE PERFORMANCE OF SINGLE QUBIT GATES](https://docs.q-ctrl.com/boulder-opal/application-notes/superconducting-qubits-improving-the-performance-of-single-qubit-gates)

## References
- [Quantum Algorithms for Beginners](https://arxiv.org/abs/1804.03719)
- [IBM Pulse tutorial](https://qiskit.org/documentation/tutorials/pulse/index.html)
- [Qiskit - Calibrating Qubits with Pulse](https://qiskit.org/textbook/ch-quantum-hardware/calibrating-qubits-pulse.html#3.-Calibrating-and-using-a-$\pi$-Pulse-)
- [Error Mitigation](https://qiskit.org/documentation/tutorials/noise/3_measurement_error_mitigation.html)
- [IMPROVING THE PERFORMANCE OF QUANTUM LOGIC GATE SETS USING QISKIT PULSE](https://q-ctrl.com/blog/improving-the-performance-of-quantum-logic-gate-sets-using-qiskit-pulse/)
- [Noise Mitigation with Delay Pulses in the IBM Quantum Experience](https://arxiv.org/pdf/2005.12520.pdf)
- [Get to the heart of real quantum hardware](https://www.ibm.com/blogs/research/2019/12/qiskit-openpulse/)
- [Qiskit Backend Specifications for OpenQASM and OpenPulse Experiments](https://arxiv.org/pdf/1809.03452.pdf)
- [OpenPulse: Software framework for quantum computing with pulses](https://www.youtube.com/watch?v=uBw2fo1rwr8)
- [IBM-Quantum-QCE20-Tutorials](https://github.com/Travis-S-IBM/IBM-Quantum-QCE20-Tutorials/tree/master/Hardware)
